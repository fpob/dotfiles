#!/usr/bin/env python3

import os
import hashlib
import re
import unicodedata
import binascii
import shlex
import datetime
import uuid
import functools
import itertools
import inspect
import click


class lu_str(str):
    """
    String (str) extended by format specifier `:u` and `:l`.

    Format specifier `:u` converts string to upper case and `:l` to lowercase,
    eg. '{my_str:u}'. These two format specifiers can be added after standard
    str format specifiers, eg. '{my_str:10s:u}' is valid.

    >>> my_str = lu_str('Hello World!')
    >>> '{:l}'.format(my_str)
    'hello world!'
    >>> '{:u}'.format(my_str)
    'HELLO WORLD!'
    >>> '{:>20s}'.format(my_str)
    '        Hello World!'
    >>> '{:>20s:l}'.format(my_str)
    '        hello world!'
    >>> '{:>20s:u}'.format(my_str)
    '        HELLO WORLD!'
    """

    def __format__(self, fmt):
        if ':' in fmt:
            str_fmt, lu_fmt = fmt.split(':')
            return self.__format__(lu_fmt).__format__(str_fmt)
        if fmt == 'l':
            return self.lower()
        elif fmt == 'u':
            return self.upper()
        return super().__format__(fmt)


class File:
    def __init__(self, path, dir, name, ext):
        self.path, self.dir, self.name, self.ext = path, dir, name, ext

    def __str__(self):
        return self.path

    @classmethod
    def from_path(cls, file_path):
        file_path = os.path.abspath(file_path)
        file_dir, file_name = os.path.split(file_path)
        file_name, file_ext = os.path.splitext(file_name)
        if file_ext in {'.gz', '.xz', '.lzma', '.bz', '.bz2', '.Z'}:
            file_name, second_ext = os.path.splitext(file_name)
            file_ext = second_ext + file_ext
        return cls(file_path, file_dir, file_name, file_ext)


class FormatVariableError(RuntimeError):
    def __init__(self, message, name):
        super().__init__(message)
        self.name = name


class FormatVariable:
    def __init__(self, name, value):
        self.name = name
        self._value = value

    @property
    def value(self):
        return self._value

    def __repr__(self):
        return '<{}>'.format(self.name)

    def __str__(self):
        return str(self.value)

    def __format__(self, fmt):
        try:
            return self.value.__format__(fmt)
        except ValueError as e:
            raise FormatVariableError(
                "Uknown format code '{}' for variable '{}'".format(fmt, self.name),
                self.name
            )


class FormatVariableGenerator(FormatVariable):
    def __init__(self, name, generator, *args, **kwargs):
        super().__init__(name, None)
        del self._value
        self.generator = generator
        self.args = args
        self.kwargs = kwargs

    @property
    def value(self):
        if '_value' not in self.__dict__:
            self._value = self.generator(*self.args, **self.kwargs)
        return self._value


def format_variable(name, lazy=False):
    """
    Decorator for functions and callable classes which generates value for
    format variables.
    Wraps return value of decorated function with FormatVariable or
    FormatVariableWrapper if lazy=True.

    Examples:

    >>> @format_variable('foo')
    ... def var_foo():
    ...     return 'foo value'
    ...
    >>> var_foo.name
    'foo'
    >>> value = var_foo()
    >>> type(value)
    <class 'formatters.FormatVariable'>
    >>> str(value)
    'foo value'
    >>> '{:s}'.format(value)
    'foo value'
    """
    def inner(fun):
        fun.name = name

        if inspect.isclass(fun):
            fun.__call__ = format_variable(name, lazy)(fun.__call__)
            return fun

        @functools.wraps(fun)
        def decorator(*args, **kwargs):
            if lazy:
                return FormatVariableGenerator(name, fun, *args, **kwargs)
            return FormatVariable(name, fun(*args, **kwargs))
        return decorator
    return inner


def format_args(values):
    """
    Generate list of FormatVariable instances from list of values.
    """
    return [FormatVariable(i, val) for i, val in enumerate(values)]


def format_kwargs(variables):
    """
    Generate dict from FormatVariable instances.
    """
    return {var.name: var for var in variables}


@format_variable('N')
def name(file):
    return lu_str(file.name)


@format_variable('E')
def ext(file):
    return lu_str(file.ext)


@format_variable('i')
class Sequence:
    def __init__(self, start):
        self.counter = itertools.count(start)

    def __call__(self):
        return next(self.counter)


@format_variable('now')
class TimeNow:
    def __init__(self):
        self.now = datetime.datetime.now()

    def __call__(self):
        return self.now


@format_variable('ascii')
def asciize(file):
    normalized = (unicodedata.normalize('NFKD', file.name)
                  .encode('ASCII', 'ignore').decode('ASCII'))
    return lu_str(re.sub(r'[^a-zA-Z0-9/]+', '-', normalized).strip('-'))


@format_variable('win')
def windows(file):
    return lu_str(re.sub(r'[\x00-\x1f/?<>\\:*|"^]', '_', file.name).rstrip('.'))


def file_hash(algorithm):
    @format_variable(algorithm, lazy=True)
    def file_hash_inner(file):
        h = hashlib.new(algorithm)
        with open(file.path, 'rb') as f:
            while True:
                data = f.read(65536)
                if not data:
                    break
                h.update(data)
        return lu_str(h.hexdigest())
    return file_hash_inner


@format_variable('crc32', lazy=True)
def crc32(file):
    h = 0
    with open(file.path, 'rb') as f:
        while True:
            data = f.read(65536)
            if not data:
                break
            h = binascii.crc32(data, h)
    return lu_str('{:08x}'.format(h & 0xffffffff))


@format_variable('uuid', lazy=True)
def random_uuid():
    return uuid.uuid4()


def create_rename_table(files, fmt, parse_re='', sequence_start=1):
    rename_table = list()

    parse_cre = re.compile(parse_re)
    seq = Sequence(sequence_start)
    now = TimeNow()

    for file in map(File.from_path, files):
        fmt_args = []
        fmt_kwargs = format_kwargs([
            name(file),
            ext(file),
            seq(),
            now(),
            asciize(file),
            windows(file),
            crc32(file),
            file_hash('md5')(file),
            file_hash('sha1')(file),
            file_hash('sha256')(file),
            random_uuid()
        ])

        parse_match = parse_cre.search(file.name)
        if parse_match:
            fmt_args.extend(format_args(
                lu_str(value) for value in parse_match.groups()
            ))
            fmt_kwargs.update(format_kwargs(
                FormatVariable(name, lu_str(value))
                for name, value in parse_match.groupdict().items()
            ))

        try:
            file_new_name = fmt.format(*fmt_args, **fmt_kwargs)
        except KeyError as e:
            raise FormatVariableError("Undefined variabe '{}'".format(str(e)), str(e))
        except IndexError as e:
            raise FormatVariableError('Undefined match reference', '#')

        if '/' in file_new_name:
            raise ValueError("Invalid filename '%s' (contains „/“)" % file_new_name)

        file_new = os.path.join(file.dir, file_new_name)
        if file.path != file_new:
            rename_table.append((file.path, file_new))

    return rename_table


def apply_rename_table(rename_table, dry_run=False):
    for file_dir, files in itertools.groupby(sorted(rename_table),
                                             key=lambda i: os.path.dirname(i[0])):
        files = list(files)
        dir_content = ({os.path.join(file_dir, f) for f in os.listdir(file_dir)}
                       - {old for old, new in files})

        exists = False
        overwrite = set()
        new_names = set()
        not_unique = set()

        for old, new in files:
            new_name = os.path.basename(new)
            if os.path.exists(new):
                exists = True
            if new in dir_content:
                overwrite.add(new_name)
            if new_name in new_names:
                not_unique.add(new_name)
            new_names.add(new_name)

        if not_unique:
            raise RuntimeError(
                "Some new file names in directory '{}' are not unique"
                .format(file_dir, repr(not_unique))
            )

        elif overwrite:
            raise RuntimeError(
                "Can't rename files in directory '{}', some files would be overwriten"
                .format(file_dir)
            )

        elif exists and not dry_run:
            suffix = '__ren-' + str(int(now.timestamp()))
            for old, new in files:
                os.rename(old, new + suffix)
            for _, new in files:
                os.rename(new + suffix, new)

        elif not dry_run:
            for old, new in files:
                os.rename(old, new)


@click.command()
@click.argument('fmt', metavar='FORMAT')
@click.argument('files', type=click.Path(exists=True), nargs=-1)
@click.option('-d', '--dry-run', is_flag=True, default=False,
              help='Dont rename only print old names and new names.')
@click.option('-s', '--seq-start', default=0, type=int,
              help='Sequence start (variable „i“).')
@click.option('-p', '--parse', default='', type=re.compile, metavar='REGEX',
              help='Parse original filename without extension. Python'
                   ' regular expression. Matches are added to variables.')
def main(fmt, files, dry_run, seq_start, parse):
    """
    FORMAT   - Python format string (str.format).

    Format Variables:

    \b
    {N}      - original name without extension
    {E}      - file extension with dot
    {i}      - sequence, accepts number format specifiers (eg. {i:03d})
    {now}    - script start date, format specifier is strftime format string
               (default: '%Y-%m-%d %H:%M:%S.%f')
    {ascii}  - asciized filename
    {win}    - Window$ safe filename
    {crc32}  - CRC32 hash (8x)
    {md5}    - MD5 hash (32x)
    {sha1}   - SHA1 hash (40x)
    {sha256} - SHA256 hash (64x)
    {uuid}   - UUID 4 (randomly generated)

    Variables from parse regex overwrites values of these variables!

    Name ({N}), extension ({E}) and variables from parse regex can be converted
    to lower-case with format specifier ':l' and to upper-case with ':u'. This
    also applies to all hashes, but they are by default lower-case.
    """

    try:
        rename_table = create_rename_table(
            files, fmt, parse_re=parse, sequence_start=seq_start)

        apply_rename_table(rename_table, dry_run=dry_run)

        if dry_run:
            print('\n'.join('rename{}'.format(repr(s)) for s in rename_table))

    except Exception as e:
        click.echo(e, err=True)
        raise click.Abort() from e


if __name__ == '__main__':
    # pylint: disable=unexpected-keyword-arg,no-value-for-parameter
    main(help_option_names=['-h', '--help'])
