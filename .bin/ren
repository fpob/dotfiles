#!/usr/bin/env python3

import os
import hashlib
import re
import unicodedata
import binascii
import shlex
import datetime
import uuid
import itertools
import click


class lu_str(str):
    """
    String (str) extended by format specifier `:u` and `:l`.

    Format specifier `:u` converts string to upper case and `:l` to lowercase,
    eg. '{my_str:u}'. These two format specifiers can be added after standard
    str format specifiers, eg. '{my_str:10s:u}' is valid.

    >>> my_str = lu_str('Hello World!')
    >>> '{:l}'.format(my_str)
    'hello world!'
    >>> '{:u}'.format(my_str)
    'HELLO WORLD!'
    >>> '{:>20s}'.format(my_str)
    '        Hello World!'
    >>> '{:>20s:l}'.format(my_str)
    '        hello world!'
    >>> '{:>20s:u}'.format(my_str)
    '        HELLO WORLD!'
    """

    def __format__(self, fmt):
        if ':' in fmt:
            str_fmt, lu_fmt = fmt.split(":")
            return self.__format__(lu_fmt).__format__(str_fmt)
        if fmt == "l":
            return self.lower()
        elif fmt == "u":
            return self.upper()
        return super().__format__(fmt)


class LazyFormatVariable:
    def __init__(self, generator, *args, **kwargs):
        self.generator = generator
        self.args = args
        self.kwargs = kwargs

    def __call__(self):
        if "result" not in self.__dict__:
            self.result = self.generator(*self.args, **self.kwargs)
        return self.result

    def __getattr__(self, name):
        return getattr(self(), name)

    def __str__(self):
        return str(self())

    def __format__(self, fmt):
        return self().__format__(fmt)


def lazy_generator(function):
    def decorator(*args, **kwargs):
        return LazyFormatVariable(function, *args, **kwargs)
    return decorator


@lazy_generator
def filename_asciize(file_name):
    normalized = (unicodedata.normalize("NFKD", file_name)
                  .encode("ASCII", "ignore").decode("ASCII"))
    return re.sub(r"[^a-zA-Z0-9/]+", "-", normalized).strip("-")


@lazy_generator
def filename_windows(file_name):
    re.sub(r'[\x00-\x1f/?<>\\:*|"^]', "_", file_name).rstrip(".")


@lazy_generator
def file_hash(algorithm, file_path):
    h = hashlib.new(algorithm)
    with open(file_path, "rb") as f:
        while True:
            data = f.read(65536)
            if not data:
                break
            h.update(data)
    return lu_str(h.hexdigest())


@lazy_generator
def file_crc32(file_path):
    h = 0
    with open(file_path, "rb") as f:
        while True:
            data = f.read(65536)
            if not data:
                break
            h = binascii.crc32(data, h)
    return lu_str("{:08x}".format(h & 0xffffffff))


def path_split(file_path):
    file_dir = os.path.dirname(file_path)
    file_name = os.path.basename(file_path)
    file_name, file_ext = os.path.splitext(file_name)
    if file_ext in {".gz", ".xz", ".lzma", ".bz", ".bz2", ".Z"}:
        file_name, second_ext = os.path.splitext(file_name)
        file_ext = second_ext + file_ext
    return file_dir, file_name, file_ext


def rename_file(old, new, overwrite=False, dump=False):
    if dump:
        click.echo("{}\t{}\t{}".format("mv -f" if overwrite else "mv",
                                       shlex.quote(old), shlex.quote(new)))
    elif os.path.exists(new) and not overwrite:
        click.echo(("Can't rename „{}“ to „{}“, file already exists"
                    .format(old, new)), err=True)
    else:
        os.rename(old, new)


@click.command()
@click.option("-d", "--dump", is_flag=True, default=False,
              help="Dont rename only print shell mv commands.")
@click.option("-s", "--seq-start", default=0, type=int,
              help="Sequence start (variable „i“).")
@click.option("-p", "--parse", default='', type=re.compile, metavar="REGEX",
              help="Parse original filename without extension. Python"
                   " regular expression. Matches are added to variables.")
@click.argument("fmt", metavar="FORMAT")
@click.argument("files", type=click.Path(exists=True), nargs=-1)
def main(dump, seq_start, parse, fmt, files):
    """
    FORMAT   - Python format string (str.format).

    Format Variables:

    \b
    {N}      - original name without extension
    {E}      - file extension with dot
    {i}      - sequence, accepts number format specifiers (eg. {i:03d})
    {now}    - script start date, format specifier is strftime format string
               (default: '%Y-%m-%d %H:%M:%S.%f')
    {ascii}  - asciized filename
    {win}    - Window$ safe filename
    {crc32}  - CRC32 hash (8x)
    {md5}    - MD5 hash (32x)
    {sha1}   - SHA1 hash (40x)
    {sha256} - SHA256 hash (64x)
    {uuid}   - UUID 4 (randomly generated)

    Variables from parse regex overwrites values of these variables!

    Name ({N}), extension ({E}) and variables from parse regex can be converted
    to lower-case with format specifier ':l' and to upper-case with ':u'. This
    also applies to all hashes, but they are by default lower-case.
    """

    # os.path.realpath() resolves symlinks which is unacceptable
    files = [os.path.normpath(os.path.join(os.environ['PWD'],
                                           os.path.expanduser(f)))
             for f in files]

    to_rename = list()

    seq = itertools.count(seq_start)
    now = datetime.datetime.now()

    for file in files:
        file_dir, file_name, file_ext = path_split(file)

        fmt_args = []
        fmt_kwargs = {
            "N": lu_str(file_name),
            "E": lu_str(file_ext),
            "i": next(seq),
            "now": now,
            "ascii": filename_asciize(file),
            "win": filename_windows(file),
            "crc32": file_crc32(file),
            "md5": file_hash("md5", file),
            "sha1": file_hash("sha1", file),
            "sha256": file_hash("sha256", file),
            "uuid": uuid.uuid4(),
        }

        parse_match = parse.search(file_name)
        if parse_match:
            fmt_args.extend([lu_str(v) for v in parse_match.groups()])
            fmt_kwargs.update({k: lu_str(v) for k, v in parse_match.groupdict().items()})

        try:
            file_new_name = fmt.format(*fmt_args, **fmt_kwargs)
        except KeyError as e:
            click.echo("Undefined variable %s" % str(e), err=True)
            raise click.Abort
        except IndexError as e:
            click.echo("Undefined match reference", err=True)
            raise click.Abort
        except ValueError as e:
            click.echo(e, err=True)
            raise click.Abort

        if "/" in file_new_name:
            click.echo("Invalid filename „%s“ (contains „/“)" % file_new_name)
            raise click.Abort

        file_new = os.path.join(file_dir, file_new_name)
        if file != file_new:
            to_rename.append((file_dir, file, file_new))

    for file_dir, files in itertools.groupby(
            sorted(to_rename), key=lambda i: os.path.dirname(i[1])):
        files = [i[1:] for i in files]
        dir_content = ({os.path.join(file_dir, f) for f in os.listdir(file_dir)}
                       - {old for old, new in files})

        exists = False
        overwrite = set()
        new_names = set()
        not_unique = set()

        for old, new in files:
            new_name = os.path.basename(new)
            if os.path.exists(new):
                exists = True
            if new in dir_content:
                overwrite.add(new_name)
            if new_name in new_names:
                not_unique.add(new_name)
            new_names.add(new_name)

        if not_unique:
            msg = ("Some new file names in directory „{}“ are not unique:\n* {}"
                   .format(file_dir, "\n* ".join(not_unique)))
            click.echo(msg, err=True)

        elif overwrite:
            msg = ("Can't rename files in directory „{}“, some files would be "
                   "overwriten:\n* {}".format(file_dir, "\n* ".join(overwrite)))
            click.echo(msg, err=True)

        elif exists:
            suffix = "__ren-" + str(int(now.timestamp()))
            for old, new in files:
                rename_file(old, new + suffix, dump=dump)
            for _, new in files:
                rename_file(new + suffix, new, dump=dump)

        else:
            for old, new in files:
                rename_file(old, new, dump=dump)


if __name__ == "__main__":
    # pylint: disable=unexpected-keyword-arg,no-value-for-parameter
    main(help_option_names=["-h", "--help"])
