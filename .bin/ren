#!/usr/bin/env python3

import os
import re
import unicodedata
import binascii
import shlex
import datetime
import uuid
import functools
import itertools
import inspect
import hashlib
import click


class lu_str(str):
    """
    String (str) extended by format specifier `:u` and `:l`.

    Format specifier `:u` converts string to upper case and `:l` to lowercase,
    eg. '{my_str:u}'. These two format specifiers can be added after standard
    str format specifiers, eg. '{my_str:10s:u}' is valid.

    >>> my_str = lu_str('Hello World!')
    >>> '{:l}'.format(my_str)
    'hello world!'
    >>> '{:u}'.format(my_str)
    'HELLO WORLD!'
    >>> '{:>20s}'.format(my_str)
    '        Hello World!'
    >>> '{:>20s:l}'.format(my_str)
    '        hello world!'
    >>> '{:>20s:u}'.format(my_str)
    '        HELLO WORLD!'
    """

    def __format__(self, fmt):
        if ':' in fmt:
            str_fmt, lu_fmt = fmt.split(':')
            return self.__format__(lu_fmt).__format__(str_fmt)
        if fmt == 'l':
            return self.lower()
        elif fmt == 'u':
            return self.upper()
        return super().__format__(fmt)


class FormatVariableError(RuntimeError):
    def __init__(self, message, name):
        super().__init__(message)
        self.name = name


class FormatVariable:
    """
    Special storage for str.format arguments.

    Generates better error message for format specifier errors. When error with
    specifier occurs then raise exception with name of value instead of type
    (default behavior) which is much more useful for user.
    """

    def __init__(self, name, value):
        self.name = name
        self._value = value

    @property
    def value(self):
        return self._value

    def __repr__(self):
        return '<{}>'.format(self.name)

    def __str__(self):
        return str(self.value)

    def __format__(self, fmt):
        try:
            return self.value.__format__(fmt)
        except ValueError:
            raise FormatVariableError(
                ("Uknown format code '{}' for variable '{}'"
                 .format(fmt, self.name)),
                self.name
            )


class FormatVariableGenerator(FormatVariable):
    """
    Lazy version of FormatVariable, interface is nearly same.

    Instead of value of the variable uses the generator (function) and its
    arguments.
    """

    def __init__(self, name, generator, *args, **kwargs):
        super().__init__(name, None)
        del self._value
        self.generator = generator
        self.args = args
        self.kwargs = kwargs

    @property
    @functools.lru_cache(maxsize=None)
    def value(self):
        return self.generator(*self.args, **self.kwargs)


def format_variable(name, lazy=False):
    """
    Decorator for functions and callable classes which generates value for
    format variables.
    Wraps return value of decorated function with FormatVariable or
    FormatVariableWrapper if lazy=True.

    >>> @format_variable('foo')
    ... def var_foo():
    ...     return 'foo value'
    >>> var_foo.name
    'foo'
    >>> value = var_foo()
    >>> type(value)
    <class 'ren.FormatVariable'>
    >>> str(value)
    'foo value'
    >>> '{:s}'.format(value)
    'foo value'
    """
    def inner(fun):
        fun.name = name

        if inspect.isclass(fun):
            fun.__call__ = format_variable(name, lazy)(fun.__call__)
            return fun

        @functools.wraps(fun)
        def decorator(*args, **kwargs):
            if lazy:
                return FormatVariableGenerator(name, fun, *args, **kwargs)
            return FormatVariable(name, fun(*args, **kwargs))
        return decorator
    return inner


def format_args(values):
    """
    Generate list of FormatVariable instances from list of values.
    """
    return [FormatVariable(i, val) for i, val in enumerate(values)]


def format_kwargs(variables):
    """
    Generate dict from FormatVariable instances.
    """
    return {var.name: var for var in variables}


def format_error(message, name):
    raise FormatVariableError(message, name)


def format(fmt, args, kwargs):
    """
    Wrapper for str.format. Raises more understandable exceptions when some
    error occurs. Eg. "Uknown variable 'foo'" instead of KeyError("foo").
    """
    try:
        return fmt.format(*args, **kwargs)
    except KeyError as e:
        name = str(e)
        raise FormatVariableError("Unknown variabe '{}'".format(name), name)
    except IndexError as e:
        raise FormatVariableError('Unknown reference', '#')


@format_variable('N')
def name(file):
    return lu_str(file.name)


@format_variable('E')
def ext(file):
    return lu_str(file.ext)


@format_variable('i')
class Sequence:
    def __init__(self, start):
        self.counter = itertools.count(start)

    def __call__(self):
        return next(self.counter)


@format_variable('now')
class TimeNow:
    def __init__(self):
        self.now = datetime.datetime.now()

    def __call__(self):
        return self.now


@format_variable('mtime')
def mtime(file):
    return datetime.datetime.fromtimestamp(os.path.getmtime(file.path))


@format_variable('ascii')
def asciize(file):
    normalized = (unicodedata.normalize('NFKD', file.name)
                  .encode('ASCII', 'ignore').decode('ASCII'))
    return lu_str(re.sub(r'[^a-zA-Z0-9/]+', '-', normalized).strip('-'))


@format_variable('win')
def windows(file):
    return lu_str(re.sub(r'[\x00-\x1f/?<>\\:*|"^]', '_', file.name)
                  .rstrip('.'))


def file_hash(algorithm):
    @format_variable(algorithm, lazy=True)
    @functools.lru_cache(maxsize=None)
    def file_hash_inner(file):
        if not os.path.isfile(file.path):
            format_error("Variable '{}' can not be used for directories"
                         .format(algorithm), algorithm)
        h = hashlib.new(algorithm)
        with open(file.path, 'rb') as f:
            while True:
                data = f.read(65536)
                if not data:
                    break
                h.update(data)
        return lu_str(h.hexdigest())
    return file_hash_inner


@format_variable('crc32', lazy=True)
@functools.lru_cache(maxsize=None)
def crc32(file):
    if not os.path.isfile(file.path):
        format_error("Variable 'crc32' can not be used for directories",
                     'crc32')
    h = 0
    with open(file.path, 'rb') as f:
        while True:
            data = f.read(65536)
            if not data:
                break
            h = binascii.crc32(data, h)
    return lu_str('{:08x}'.format(h & 0xffffffff))


@format_variable('uuid', lazy=True)
def random_uuid():
    return uuid.uuid4()


class File:
    def __init__(self, path, dir, name, ext):
        self.path, self.dir, self.name, self.ext = path, dir, name, ext

    def __str__(self):
        return self.path

    @classmethod
    def from_path(cls, file_path):
        file_dir, file_name = os.path.split(file_path)
        file_name, file_ext = os.path.splitext(file_name)
        if file_ext in {'.gz', '.xz', '.lzma', '.bz', '.bz2', '.Z'}:
            file_name, second_ext = os.path.splitext(file_name)
            file_ext = second_ext + file_ext
        return cls(file_path, file_dir, file_name, file_ext)


def create_rename_table(files, fmt, parse_re='', parse_ext=False, sequence_start=0):
    rename_table = list()

    parse_cre = re.compile(parse_re)
    seq = Sequence(sequence_start)
    now = TimeNow()

    for file in map(File.from_path, files):
        fmt_args = []
        fmt_kwargs = format_kwargs([
            name(file),
            ext(file),
            seq(),
            now(),
            mtime(file),
            asciize(file),
            windows(file),
            crc32(file),
            file_hash('md5')(file),
            file_hash('sha1')(file),
            file_hash('sha256')(file),
            random_uuid()
        ])

        if parse_ext:
            parse_match = parse_cre.search(file.name + file.ext)
        else:
            parse_match = parse_cre.search(file.name)
        if parse_match:
            fmt_args.extend(format_args(
                lu_str(value) for value in parse_match.groups()
            ))
            fmt_kwargs.update(format_kwargs(
                FormatVariable(name, lu_str(value))
                for name, value in parse_match.groupdict().items()
            ))

        file_new_name = format(fmt, fmt_args, fmt_kwargs)

        if '/' in file_new_name:
            raise ValueError("Invalid filename '{}' (contains '/')"
                             .format(file_new_name))

        file_new = os.path.join(file.dir, file_new_name)
        rename_table.append((file.path, file_new))

    return rename_table


def apply_rename_table(rename_table, dry_run=False):
    rename_table = ((old, new) for old, new in rename_table if old != new)

    grouped_table = itertools.groupby(sorted(rename_table),
                                      key=lambda i: os.path.dirname(i[0]))

    for file_dir, files in grouped_table:
        files = list(files)

        dir_content = (
            {os.path.join(file_dir, f) for f in os.listdir(file_dir or '.')}
            - {old for old, new in files}
        )

        exists = False
        overwrite = set()
        new_names = set()
        not_unique = set()

        for old, new in files:
            new_name = os.path.basename(new)
            if os.path.exists(new):
                exists = True
            if new in dir_content:
                overwrite.add(new_name)
            if new_name in new_names:
                not_unique.add(new_name)
            new_names.add(new_name)

        if not_unique:
            raise RuntimeError(
                "Some new file names in directory '{}' are not unique"
                .format(file_dir, repr(not_unique))
            )

        elif overwrite:
            raise RuntimeError(
                ("Can not rename files in directory '{}', some files would be "
                 "overwriten").format(file_dir)
            )

        elif exists and not dry_run:
            suffix = '__ren-{:06x}'.format(os.getpid())
            for old, new in files:
                os.rename(old, new + suffix)
            for _, new in files:
                os.rename(new + suffix, new)

        elif not dry_run:
            for old, new in files:
                os.rename(old, new)


def rename(files, fmt, sequence_start=0, parse_re='', parse_ext=False, dry_run=False):
    """
    Rename files and returns rename table (list of tuple(old_name, new_name)).
    If dry_run is True ten nothing is renamed, just returns rename table.
    """
    rename_table = create_rename_table(files, fmt,
                                       sequence_start=sequence_start,
                                       parse_re=parse_re, parse_ext=parse_ext)
    apply_rename_table(rename_table, dry_run=dry_run)
    return rename_table


@click.command()
@click.argument('fmt', metavar='FORMAT')
@click.argument('files', type=click.Path(exists=True), nargs=-1)
@click.option('-d', '--dry-run', is_flag=True, default=False,
              help='Dont rename only print old names and new names as tsv.')
@click.option('-s', '--seq-start', default=0, type=int,
              help='Sequence start (variable „i“), default is 0.')
@click.option('-p', '--parse', default='', type=re.compile, metavar='REGEX',
              help='Python regular expression which is used to parse original '
              'filename. Matches are added to variables.')
@click.option('-e', '--parse-ext', is_flag=True, default=False,
              help='Parse file with exception, default is False.')
def main(files, fmt, dry_run, seq_start, parse, parse_ext):
    """
    Bulk renamer.

    Arguments:

      FORMAT   - Python format string (str.format).

    Format Variables:

    \b
      {N}      - original name without extension
      {E}      - file extension with dot
      {i}      - sequence, accepts number format specifiers (eg. {i:03d})
      {now}    - script start date, format specifier is strftime format string
                 (default: '%Y-%m-%d %H:%M:%S.%f')
      {mtime}  - file modification time, accepts strftime format as format
                 specifier (default: '%Y-%m-%d %H:%M:%S.%f')
      {ascii}  - asciized filename
      {win}    - Window$ safe filename
      {crc32}  - CRC32 hash (8x)
      {md5}    - MD5 hash (32x)
      {sha1}   - SHA1 hash (40x)
      {sha256} - SHA256 hash (64x)
      {uuid}   - UUID 4 (randomly generated)

    Variables from parse regex overwrites values of these variables!

    Name ({N}), extension ({E}) and variables from parse regex can be converted
    to lower-case with format specifier ':l' and to upper-case with ':u'. This
    also applies to all hashes, but they are by default lower-case.
    """

    try:
        rename_table = rename(files, fmt,
                              parse_re=parse,
                              parse_ext=parse_ext,
                              sequence_start=seq_start,
                              dry_run=dry_run)

        if dry_run:
            for ren in rename_table:
                click.echo('%s\t%s' % ren)

    except Exception as e:
        raise click.ClickException(str(e))


if __name__ == '__main__':
    main(help_option_names=['-h', '--help'])
